namespace System {
	public class ArrayLike<$T$> : MapLike<$uint, T$> {
		public func @constructer() : void {
			@base();
		}
		public varfunc get(index : uint) : T {}
		public varfunc set(index : uint, data : T) : void {}
		public varfunc getLength() : uint;
		public varfunc swap(x : uint, y : uint) : void {}
		public varfunc toBasicArray() : T[] {
			var res = $T[getLength()];
			for (var i = 0u; i < @this.getLength(); i++) res[i] = get(i);
			return res;
		}
	}
	public class MapLike<$KeyT, ValueT$> {
		public func @constructer() : void {
			@base();
		}
		public varfunc get(index : KeyT) : ValueT {}
		public varfunc set(index : KeyT, data : ValueT) : void {}
	}
	public class String : Array<$char$> {
		public func @constructer() : void {
			@base();
		}
		public func @constructer(length : uint, initChar : char) : void {
			@base(length, initChar);
		}
		public func @constructer(source : String) : void {
			@base();
			for (var i = 0u; i < source.getLength(); i++) append(source[i]);
		}
		public varfunc toBasicArray() : char[] {
			var res = $char[getLength() + 1];
			for (var i = 0u; i < @this.getLength(); i++) res[i] = get(i);
			res[getLength()] = 0 as char;
			return res;
		}
		private var data : char[];
		private var length : uint, capacity : uint;
	}
	public class Array<$T$> : ArrayLike<$T$> {
		public func @constructer() : void {
			@base();
		}
		public func @constructer(length : uint, initData : T) : void {
			@base();
			while (length--) append(initData);
		}
		public varfunc get(index : uint) : T {
			return data[index];
		}
		public varfunc set(index : uint, dt : T) : void {
			data[index] = dt;
		}
		public varfunc getLength() : uint {
			return length;
		}
		public varfunc swap(x : uint, y : uint) : void {
			var tmp = data[x];
			data[x] = data[y];
			data[y] = tmp;
		}
		public func append(dt : T) : void {
			if (length == capacity) {
				var newCapacity = capacity;
				if (capacity == 0u) newCapacity = 1u;
				else newCapacity <<= 1u;
				var newData = $T[newCapacity];
				for (var i = 0u; i < capacity; i++) newData[i] = data[i];
				data = newData, capacity = newCapacity;
			}
			data[length++] = dt;
		}

		private var data : T[];
		private var length : uint, capacity : uint;
	}
	public func sort<$T$>(array : ArrayLike<$T$>, @compare : Compare<$T, T$>, l : uint, r : uint) : void {
		if (r <= l) return ;
		// partion
		var bs = array[l], tl = l, tr = r;
		while (tl < tr) {
			while (tl < tr && array[tr] >= bs) tr--;
			array[tl] = array[tr];
			while (tl < tr && array[tl] <= bs) tl++;
			array[tr] = array[tl];
		}
		array[tl] = bs;
		sort(array, @compare, l, tl - 1u), sort(array, @compare, tl + 1u, r);
	}
	public func sort<$T$>(array : ArrayLike<$T$>, @compare : Compare<$T, T$>) : void {
		sort(array, @compare, 0u, array.getLength() - 1);
	}
	public class Compare<$T1, T2$> {
		public varfunc calculate(a : T1, b : T2) : int;
	}
	public func reverse<$T$>(array : ArrayLike<$T$>, l : uint, r : uint) : void {
		while (l < r) {
			array.swap(l, r);
			l++, r--;
		}
	}
	public func reverse<$T$>(array : ArrayLike<$T$>) : void { reverse(array, 0u, array.getLength()); }
}
class TestA<$T1, T2$> {
	protected func func1(v1 : T2) : T1;
	protected func func2(v1 : T1, v2 : T2) : T2;
}
class TestB : TestA<$int, float$> {
	protected func func1(v1 : float) : int;
	protected func func2(v2 : int, v2 : float) : int;
}
namespace System::Math {
	public func max(a : int, b : int) : int {
		if (a > b) return a;
		else return b;
	}
	public func min(a : int, b : int) : int {
		if (a > b) return b;
		else return a;
	}
    public func pow(a : long, b : long) : long {
        var res = 1ll;
        while (b > 0ll) {
            if (b & 1ll) res *= a;
            a *= a, b >>= 1ll;
        }
        return res;
    }
    public func gcd(a : long, b : long) : long {
        if (b > 0ll) return gcd(b, a % b);
        else return a;
    }
}